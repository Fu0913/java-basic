# 集合

## 1. Collection集合问答

### 1.1 List集合特点

LinkedList   Vector   ArrayList的区别？



答案：

- **从存储数据结构分析**
  ArrayList：数组
  Vector：数组
  LinkedList：双向链表 
  - 数组：可以根据下标快速查找，所以大部分情况下，查询快。但是如果要进行增删操作的时候，会需要移动、修改后面的所有元素，所以增删的开销比较大，数组对增删操作的执行效率低。而采用数组作为数据存储结构的ArrayList、Vector也存在这些特性，查询速度快（可以根据下标直接取，比迭代查找更快），增删慢。
  - 链表：增加和删除元素方便，增加或删除一个元素，仅需处理结点间的引用即可。就像人手拉手连成一排，要增加或删除某个人，只要附近的两个人换一个人牵手，对已经牵好手的人没影响。无论在哪里换人耗费的资源和时间都是一样的。但是查询不方便，需要一个个对比，无法根据下标直接查找。而采用链表结构存储的LinkedList也有这些特性，增删方便，查询慢(指的是随机查询，不是顺序查询)。

- **从并发安全上分析**
  Vector：线程安全
  ArrayList：非线程安全
  LinkedList:非线程安全

- **数据增长分析**
  Vector：缺省的情况下，增长为原数组长度的一倍。说到缺省，说明它其实是可以自主设置初始化大小的。
  ArrayList：自动增长原数组的50%。老容量+老容量>>1



### 1.2 List、Set集合对比

简述list集合和set集合的特点。



答案：

- 共同特点：都继承Collection接口。
- List特点
  List是一种有序、带索引、可以存放重复数据的集合
- Set特点
  Set是一种无序、不带下标索引、不能存放重复数据的集合



## 2. Collection集合遍历

假设顺序列表ArrayList中存储的元素是整型数字1~5，遍历每个元素，将每个元素顺序输出。（使用你能想到的所有方式进行遍历）



答案：

有以下几种方式可选：

- 直接打印集合
- 普通for循环
- 增强for循环
- 迭代器遍历
- 匿名内部类遍历
- lamabda表达式



答案1，普通for循环：

```java
public static void main(String[] args) {
    ArrayList arrayList = new ArrayList();
    arrayList.addAll(Arrays.asList(1, 2, 3, 4, 5));
    System.out.println("for循环遍历");
    for (int i = 0; i < arrayList.size(); i++) {
        System.out.print(arrayList.get(i) + " ");
    }
}
```

答案2，增强for循环：

```java
public static void main(String[] args) {
    ArrayList arrayList = new ArrayList();
    arrayList.addAll(Arrays.asList(1, 2, 3, 4, 5));
    System.out.println("增强for循环遍历");
    for (Object data : arrayList) {
        System.out.print(data + " ");
    }
}
```

答案3，迭代器遍历

```java
public static void main(String[] args) {
    ArrayList arrayList = new ArrayList();
    arrayList.addAll(Arrays.asList(1, 2, 3, 4, 5));
    System.out.println("迭代器遍历");
    Iterator iterator = arrayList.iterator();
    while (iterator.hasNext()) {
        Object object = iterator.next();
        System.out.print(object + " ");
    }
}
```

答案4，匿名内部类遍历

```java
public static void main(String[] args) {
    ArrayList arrayList = new ArrayList();
    arrayList.addAll(Arrays.asList(1, 2, 3, 4, 5));
    System.out.println("匿名内部类遍历");
    arrayList.forEach(new Consumer() {
        @Override
        public void accept(Object t) {
            System.out.print(t + " ");
        }
    });
}
```

答案5，lambda表达式（了解）

```java
public static void main(String[] args) {
    ArrayList arrayList = new ArrayList();
    arrayList.addAll(Arrays.asList(1, 2, 3, 4, 5));
    System.out.println("lambda表达式遍历");
    arrayList.forEach((a) -> {
        System.out.print(a + " ");
    });
}
```





## 3. 方法应用

### 3.1  contains()

ArrayList去除集合中字符串的重复值(字符串的内容相同则代表重复)



答案：

```java
public static void main(String[] args) {
    // 定义存放有相同数据的集合
    List<String> oldList = new ArrayList<>();
    oldList.add("mike");
    oldList.add("lily");
    oldList.add("lily");
    oldList.add("tom");
    oldList.add("tom");
    System.out.println(oldList);
    // 定义去重后的集合
    List newList = new ArrayList();
    for (String str : oldList) {
        if (!newList.contains(str)) {
            newList.add(str);
        }
    }
    // 测试输出
    System.out.println(newList);
}
```



### 3.2 retainAll()、removeAll()

有两个集合list1和list2，list1中存放了1，2，3，4，5五个元素，list2中存放了4，5，6三个元素，按要求完成下列操作

- 打印list1和list2的交集（list1和list2中都有的元素）

答案：

```java
public static void main(String[] args) {
    List list1 = new ArrayList(Arrays.asList(1, 2, 3, 4, 5));
    List list2 = new ArrayList(Arrays.asList(4, 5, 6));
    list1.retainAll(list2);
    System.out.println(list1);
}
```



- 打印list1和list2的差集（list1中有，list2中没有的元素）

答案：

```java
public static void main(String[] args) {
    List list1 = new ArrayList(Arrays.asList(1, 2, 3, 4, 5));
    List list2 = new ArrayList(Arrays.asList(4, 5, 6));
    list1.removeAll(list2);
    System.out.println(list1);
}
```



## 4. 集合使用

### 4.1 List集合的使用

定义两个集合，完成List集合的定义和遍历。

【要求】

- 定义一个集合list1存入20个随机整数
- 筛选list1中的偶数元素
- 定义一个集合list2用来接收筛选出的偶数元素
- 遍历list2



答案：

```java
public static void main(String[] args) {
    // 定义存储20个随机数的集合
    List list1 = new ArrayList();
    // 定义存储偶数的集合
    List list2 = new ArrayList();
    // 生成随机数
    Random r = new Random();
    int random = 0;
    while (list1.size() < 20) {
        random = r.nextInt(20);
        list1.add(random);
    }
    System.out.println("生成的集合为："+list1);
    // 将生成的偶数添加到list2
    for (Object data : list1) {
        Integer i = (Integer) data;
        if (i % 2 == 0) {
            list2.add(data);
        }
    }
    System.out.println("偶数集合："+list2);
}
```



### 4.2 Set集合的使用

定义一个集合，完成Set集合的定义和遍历。

【要求】

- Set集合中的元素为10个整数
- 10个整数元素为1-20的随机数
- 10个整数元素互不重复



答案：

```java
public static void main(String[] args) {
    // 创建set集合
    Set set = new HashSet();
    // 创建生成随机数对象和随机数
    Random r = new Random();
    int random = 0;
    while (set.size() < 10) {
        random = r.nextInt(20)+1;
        set.add(random);
    }
    // 输出集合
    System.out.println(set);
}
```



## 5. TreeSet排序问题

### 5.1 奇偶排序

将1-10按照奇数在前偶数在后，奇数正序，偶数倒序的方式保存到Set集合中（排序）



答案：

```java
public class Test5_1_odd {
    public static void main(String[] args) {
        Set<Integer> set = new TreeSet<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                if (o1 % 2 != 0 && o2 % 2 != 0) { // 两数都是奇数
                  return o1 - o2; // 升序
                } else if (o1 % 2 == 0 && o2 % 2 != 0) { // 偶奇
                  return 1;
                } else if (o1 % 2 != 0 && o2 % 2 == 0) { // 奇偶
                  return -1;
                } else {
                  return o2 - o1; // 降序
                }
              }
        });
        for (int i = 1; i <= 10; i++) {
            set.add(i);
        }
        System.out.println(set);
    }
}
```



### 5.2 成绩单应用

将学生按照成绩保存到集合中，并且名字叫tom的学生不管考多少分都位于班级的第一位。



答案：

```java
public class Test5_2_ReportCards {
    public static void main(String[] args) {
        Set<Student> set = new TreeSet<>(new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                if ("tom".equals(s1.getName()) && !"tom".equals(s2.getName())) {
                    return -1;
                } else if (!"tom".equals(s1.getName()) && "tom".equals(s2.getName())) {
                    return 1;
                } else {
                    return s1.getScore() - s2.getScore();
                }
            }
        });

        Student student1 = new Student("tom", 80);
        Student student2 = new Student("mike", 90);
        Student student3 = new Student("lily", 20);
        Student student4 = new Student("chris", 23);
        set.add(student3);
        set.add(student2);
        set.add(student1);
        set.add(student4);

        for (Student student : set) {
            System.out.println(student);
        }
    }
}

class Student {
    private String name;
    private int score;

    public Student(String name, int score) {
        super();
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student [name=" + name + ", score=" + score + "]";
    }
}
```



### 5.3 对比应用

通过两种方式实现：Comparable接口和Comparator接口

【要求】

- 设计Teacher类，包含属性id，name,age，创建Teacher对象。
- 将对象保存在TreeSet集合中并且排序。
- 排序规则为：先通过名字排序，名字相同的时候通过年龄进行排序，年龄相同时通过id排序。



答案：

```java
public class Teacher implements Comparable {
    private long id;
    private String name;
    private int age;

    public Teacher() {
    }

    public Teacher(long id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    public void setId(long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public long getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }

    public String toString() {
        return "Teacher[id=" + id + ",name=" + name + ",age=" + age + "]";
    }

    public int hashCode() {
        return (int) this.id;
    }

    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof Teacher)) {
            return false;
        }
        Teacher tea = (Teacher) obj;
        if (this.id == tea.id && this.name.equals(tea.name) && this.age == tea.age) {
            return true;
        }
        return false;
    }

    // 先通过名字排序，名字相同的时候通过年龄进行排序，年龄相同时通过id排序
  	@Override
    public int compareTo(Object o) {
        Teacher teacher = (Teacher) o;
        if (this.name.equals(teacher.name)) {
            if (this.age == teacher.age) {
                return (int) (this.id - teacher.id);
            } else {
                return this.age - teacher.age;
            }
        } else {
            return this.name.compareTo(teacher.name);
        }
    }
}
```


```java
public class Test5_3_Diff {
    public static void main(String[] args) {
        Test t = new Test();
        t.test1();
        t.test2();
    }

    public void test1() {
        Set set = new TreeSet();
        set.add(new Teacher(1L, "tom6", 21));
        set.add(new Teacher(2L, "tom2", 22));
        set.add(new Teacher(3L, "tom3", 24));
        set.add(new Teacher(4L, "tom3", 23));
        set.add(new Teacher(5L, "tom3", 24));
        set.add(new Teacher(5L, "tom4", 24));
        set.add(new Teacher(7L, "tom6", 26));
        set.add(new Teacher(6L, "tom6", 26));
        System.out.println("*************使用Comparable实现排序*******************");
        this.showCollection(set);
    }

    public void test2() {
        Set set = new TreeSet(new Comparator() {
            public int compare(Object o1, Object o2) {
                Teacher t1 = (Teacher) o1;
                Teacher t2 = (Teacher) o2;
                if (t1.getName().equals(t2.getName())) {
                    if (t1.getAge() == t2.getAge()) {
                        return (int) (t1.getId() - t2.getId());
                    } else {
                        return t1.getAge() - t2.getAge();
                    }
                } else {
                    return t1.getName().compareTo(t2.getName());
                }
            }
        });
        set.add(new Teacher(1L, "tom6", 21));
        set.add(new Teacher(2L, "tom2", 22));
        set.add(new Teacher(3L, "tom3", 24));
        set.add(new Teacher(4L, "tom3", 23));
        set.add(new Teacher(5L, "tom3", 24));
        set.add(new Teacher(5L, "tom4", 24));
        set.add(new Teacher(7L, "tom6", 26));
        set.add(new Teacher(6L, "tom6", 26));
        System.out.println("*************使用Comparator实现排序*******************");
        this.showCollection(set);
    }

    private void showCollection(Collection c) {
        Iterator it = c.iterator();
        System.out.println("**遍历集合元素**");
        while (it.hasNext()) {
            Object obj = it.next();
            System.out.println("\t" + obj);
        }
        System.out.println("**遍历集合元素**");
    }
}
```



## 6. List集合自定义实现（选做题）

### 6.1 自定义实现ArrayList

实现MyList代码，模拟ArrayList的部分功能。



答案：

```java
public interface MyList { 
 		public void add(int index,Object obj);		//在指定位置添加对象
		public void add(Object obj); 							//在最后位置添加对象
		public Object remove(int index);					//删除指定位置上的对象 
		public void set(int index,Object obj);		//修改指定位置上的数据
		public Object get(int index);							//获取指定位置上的数据
		public int size();												//获取当前数据结构当前的长度
		public void clear(); 											//清空所有的数据
}
```

```java
public class MyArrayList {
    // 定义数组容器
    private Object[] elementData;
    // 默认容量为10
    private static final int DEFAULT_CAPACITY = 10;
    // 实际ArrayList的大小
    private int size;

    // 提供有参构造器 自定义初始容量
    public MyArrayList(int initialCapacity) {
        if (initialCapacity < 0) {
            throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
        }
        this.elementData = new Object[initialCapacity];
    }

    // 无参构造初始化 将默认10传递给有参构造器
    public MyArrayList() {
        this(DEFAULT_CAPACITY);
    }

    // 在尾部添加元素
    public void add(Object object) {
        // 1.判断实际存放的数组容量是否大于elementData.length
        if (size == elementData.length) {
            // //最小传一个比当前容量大的值给他扩容
            grow(size + 1);
        }
        // 2.使用下标进行赋值
        elementData[size++] = object;
    }

    // 在指定位置添加元素
    public void add(int index, Object object) {
        rangeCheckForAdd(index);
        if (size == elementData.length) {
            // 最小传一个比当前容量大的值给他扩容
            grow(size + 1);
        }
        // size-index 从当前值和后面的值往后移动，多了一个值，所以不需要-1
        System.arraycopy(elementData, index, elementData, index + 1, size - index); // 1 2 3 4 5
        elementData[index] = object;
        size++;
    }

    // 获取指定索引元素
    public Object get(int index) {
        rangeCheckForAdd(index);
        return elementData[index];
    }

    // 检查数组是否越界
    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) {
            throw new ArrayIndexOutOfBoundsException("数组越界异常");
        }
    }

    // 删除指定索引元素
    public Object remove(int index) {
        rangeCheckForAdd(index);
        Object old = elementData[index];
        // 移动元素位置 并且将最后一位置空
        // 算出需要移动的个数
        int numMoved = size - index - 1;
        if (numMoved > 0)
            // size-index-1 下标是少1的 而且是往前挪
            System.arraycopy(elementData, index + 1, elementData, index, numMoved);
        // 注意numMoved的判断，如果是删除最后一个元素，虽然不移动也必须置空
        elementData[--size] = null;
        return old;
    }

    // 删除对象
    public boolean remove(Object o) {
        for (int i = 0; i < size; i++) {
            if (o.equals(elementData[i])) {
                remove(i);
                return true;
            }
        }
        return false;
    }

    // 清空数据
    public void clear() {
        for (int i = 0; i < size; i++) {
            elementData[i] = null;
        }
        size = 0;
    }

    //扩容 
    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0) newCapacity = minCapacity;
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    public static void main(String[] args) {
        MyArrayList my = new MyArrayList(1);
        my.add(1);
        my.add(2);
        my.add(3);
        System.out.println("获取第一个位置" + my.get(1));
        my.remove(1);
        my.clear();
        System.out.println(my.size);
    }
}
```



### 6.2 自定义实现LinkedList

完成MyLinkedList代码，模拟LinkedList的部分功能



答案：

```java
public class MyLinkedList{
  	private class Node{
        //存放元素的值
        private Object data;
        //存放上一个节点 
        private Node pre; 
        //存放下一个节点 
        private Node next; 
		}
  
  	//补全以下四种方法 
  	public void add(Object o){} 
  	public void add(int index,Object o){} 
  	public void remove(int index){} 
  	public Object get(int index){} 
}
```

```java
public class MyLinkedList<T> {
    private Node<T> first;// 定义头节点
    private Node<T> last;// 定义尾节点
    private int size;// 链表的长度

    private class Node<T> {
        private T data;// 存放元素的值
        private Node<T> pre; // 存放上一个节点
        private Node<T> next;// 存放下一个节点
    }

    // 补全以下四种方法
    public void add(T t) {
        //把t封装成node对象
        Node<T> node = new Node<>();
        node.data = t;
        //判断队列是否为空
        if (first == null) {
            //添加进队列的节点既是头节点，也是尾节点
            first = node;
            last = node;
        } else {
            //尾节点的下一个指向添加进来的node
            last.next = node;
            //node的上一个节点指向尾节点
            node.pre = last;
            //node节点成为新的尾节点
            last = node;
        }
        size++;
    }

    public void add(int index, T t) throws Exception {
        //参数校验
        checkIndex(index);
        //把t封装成node对象
        Node<T> newNode = new Node<>();
        newNode.data = t;
        //获取该index上的节点
        Node<T> oldNode = get(index);
        //获取前一个节点
        Node<T> preNode = oldNode.pre;
        if (preNode == null) {
            //老节点的前一个节点指向新添加的节点
            oldNode.pre = newNode;
            //新节点的下一个节点指向老的节点
            newNode.next = oldNode;
            //新的节点变成头节点
            first = newNode;
        } else {
            //前一个节点的下一个节点指向添加进来的节点
            preNode.next = newNode;
            //新的节点的前一个节点指向原来的前一个节点
            newNode.pre = preNode;
            //老的节点的前一个节点指向新的节点
            oldNode.pre = newNode;
            //新的节点的下一个节点指向老的节点
            newNode.next = oldNode;
        }
        size++;
    }

    public void remove(int index) throws Exception {
        //校验参数
        checkIndex(index);
        //获取要删除的节点
        Node<T> node = get(index);
        Node<T> preNode = node.pre;
        Node<T> nextNode = node.next;
        if (preNode == null && nextNode == null) {
            //该双向链表中只有一个节点
            size = 0;
            return;
        } else if (preNode == null && nextNode != null) {
            //下一个节点的前一个节点置为null
            nextNode.pre = null;
            //要删除的节点的下一个节点置为null
            node.next = null;
            first = nextNode;
        } else if (preNode != null && nextNode == null) {
            //前一个节点的下一个节点置为null
            preNode.next = null;
            //要删除节点的前一个节点置为null
            node.pre = null;
            last = preNode;
        } else {
            //要删除的节点的上一个节点和下一个节点全置为null
            node.pre = null;
            node.next = null;
            //前一个节点的下一个节点指向下一个节点，下一个的前一个节点指向前一个节点
            preNode.next = nextNode;
            nextNode.pre = preNode;
        }
        size--;
    }

    private Node<T> get(int index) throws Exception {
        //定义一个节点
        Node<T> node = null;
        //校验index的合法性
        checkIndex(index);
        //队列里面有元素
        if (first != null) {
            node = first;
            for (int i = 0; i < index; i++) {
                //node后移
                node = node.next;
            }
        }
        return node;
    }

    public int getSize() {
        return this.size;
    }

    public void show() throws Exception {
        for (int i = 0; i < getSize(); i++) {
            if (i == getSize() - 1) {
                System.out.println(get(i).data);
            } else {
                System.out.print(get(i).data + " -> ");
            }
        }
    }

    private void checkIndex(int index) throws Exception {
        if (index < 0 || index >= getSize()) {
            throw new Exception("参数index不合法");
        }
    }

    public static void main(String[] args) throws Exception {
        MyLinkedList<Integer> linkedList = new MyLinkedList<>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        linkedList.add(4);
        linkedList.add(5);
        linkedList.show();
        linkedList.add(2, 1);
        linkedList.show();
        linkedList.remove(2);
        linkedList.show();
    }
}
```



## 7. Map集合问答

1）map可以使用迭代器遍历吗？为什么？

答案：

不可以。Map没有继承Iterable接口，而迭代器方法是Iterable接口的抽象方法



2）map的键和值能为空吗？为什么？

答案：

HashMap的键和值可以为空，HashTable的键和值都不能为空



## 8. Map集合使用和遍历

1）创建一个Map集合，里面有如下元素{香蕉 = 5.6 ，樱桃 = 25 ，桃子 = 5.6 ， 苹果 = 2.3}，按要求完成：

- 遍历该map集合，并且统计有多少种水果（key）用两种方式进行遍历
- 将“香蕉”的价格修改为10.9，并删除桃子这组数据，将修改后的map中所有key和value都输出到控制台



答案：

```java
public class Test8_Fruit {
    public static void main(String[] args) {
        Map<String, Double> map = new HashMap<>();
        map.put("香蕉", 5.6D);
        map.put("樱桃", 25D);
        map.put("桃子", 5.6D);
        map.put("苹果", 2.3D);
        first(map);
        second(map);
        System.out.println("一共有" + map.size() + "个水果");

        // 修改香蕉的价格
        map.put("香蕉", 10.9D);
        // 删除桃子数据
        map.remove("桃子");
        first(map);
    }

    private static void first(Map<String, Double> map) {
        Set<String> set = map.keySet();
        for (String str : set) {
            System.out.println(str + " " + map.get(str));
        }
    }

    private static void second(Map<String, Double> map) {
        Set<Map.Entry<String, Double>> set = map.entrySet();
        for (Map.Entry<String, Double> entry : set) {
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }
}
```



2）统计字符串中每个字符出现的次数，String s = "aabbddccaefdd";

【提示】

- 可使用Map<Character, Integer>集合，键存放字符，值存放出现的次数



答案：

```java
public static void main(String[] args) {
    Map<Character, Integer> map = new HashMap<>();
    String s = "aabbddccaefdd";
    char[] c = s.toCharArray();
    for (int i = 0; i < c.length; i++) {
        char key = c[i];
        if (!map.containsKey(key)) {
            map.put(key, 1);
        } else {
            int value = map.get(key);
            map.put(key, value + 1);
        }
    }
    System.out.println(map);
}
```



## 9. Map集合常用方法

按要求完成以下步骤：

1. 键盘录入整行字符串(sc.nextLine())，遇到quit结束录入

   录入字符串格式为：`学号$姓名$年龄$分数`，示例如下：

   ```java
   005$zs$20$78.4
   003$jack$21$88.3
   002$jack$20$88.3
   004$tom$20$88.3
   001$rose$20$86.2
   quit
   ```

2. 拆解上述整行的字符串得到属性值，然后实例化学生对象，按照"$"分割字符串 

   提醒1：split()方法
   提醒2：String --> Integer 转换

3. 将学生对象添加到Map<学生，学号>集合中 

   要求：添加时先按照成绩逆序，如果成绩相同按照name降序，name也相同再按照age升序，age也相同按照id升序

4. 遍历集合

5. 判断003号学生是否存在 

   如果存在，则删除该学生 

6. 再次遍历集合

   要求采用另一种方式遍历



答案：

```java
/*
005$zs$20$78.4
003$jack$21$88.3
002$jack$20$88.3
004$tom$20$88.3
001$rose$20$86.2
quit
 */
public class Test09_Map {
    public static void main(String[] args) {
        //1.准备比较器对象
        Comparator<Student> comp = new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                //1.先按照double成绩逆序
                int r;
                if (o2.getScore() > o1.getScore())
                    r = 1;
                else if (o2.getScore() < o1.getScore())
                    r = -1;
                else
                    r = 0;

                //2.成绩相同则按照name降序
                if (r == 0) {
                    r = o2.getName().compareTo(o1.getName());
                    //3.name也相同则按照age升序
                    if (r == 0) {
                        r = o1.getAge() - o2.getAge();
                        //4.age也相同则按照id升序
                        if (r == 0) {
                            r = o1.getId().compareTo(o2.getId());
                        }
                    }
                }

                return r;
            }
        };

        //2.准备map集合，传入比较器对象
        Map<Student, String> map = new TreeMap<>(comp);

        //3.从键盘录入有效字符串并处理
        String line = null;
        Scanner sc = new Scanner(System.in);
        while (true) {
            //3.1 录入字符串
            System.out.println("请按照格式【学号$姓名$年龄$分数】录入字符串:");
            line = sc.nextLine();

            //3.2 判断录入是否为quit
            if ("quit".equals(line)) {
                System.out.println("结束录入");
                break;
            }

            //3.3 拆分字符串，获取学生的各个属性，最后封装成学生对象
            String[] arr = line.split("\\$");
            // [001, zs, 20, 78.4]
            String id = arr[0];
            String name = arr[1];
            //	String --> int
            int age = Integer.parseInt(arr[2]);
            //	String --> double
            double score = Double.parseDouble(arr[3]);
            Student s = new Student(id, name, age, score);

            //3.4 将对象添加到Map集合
            map.put(s, id);
        }

        //4.第一种方式遍历集合
        Set<Student> set = map.keySet();
        Student stu = null;
        for (Student s : set) {
            //获取003对象
            if ("003".equals(s.getId()))
                stu = s;
            System.out.println(s + " " + map.get(s));
        }

        //5.删除003学生
        System.out.println("---- 删除003号学生 ----");
        if (stu != null)
            map.remove(stu);
        else
            System.out.println("003不存在，无法删除！");

        //6.第二种方式遍历
        Set<Map.Entry<Student, String>> entrySet = map.entrySet();
        for (Map.Entry<Student, String> entry : entrySet) {
            System.out.println(entry.getKey() + " " + entry.getValue());
        }
    }
    
    //split方法测试，按照$分割
    public static void main01(String[] args) {
        String s = "1$2$3";
        String[] arr = s.split("\\$");
        System.out.println(arr.length);
    }
}

class Student {
    private String id;
    private String name;
    private int age;
    private double score;

    public Student() {
    }

    public Student(String id, String name, int age, double score) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.score = score;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", score=" + score +
                '}';
    }
}
```



# 泛型

## 10. 泛型概念

使用泛型的好处是，什么是泛型擦除？

答案：

- 泛型，即“参数化类型”。创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。

- 泛型擦除：Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，变为原始类型Object，这个过程即类型擦除。

  

## 11. 泛型使用

定义一个通用的(带泛型)的方法，该方法可以返回Collection集合中的最大值



答案：

```java
public class Test11_Genericity {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(3,2,9,1,7,6);
        Integer max = getMax(list, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1-o2;
            }
        });
        System.out.println("第一种 max: " + max);

        List<Double> list2 = Arrays.asList(3.1,2.9,1.7,6.3,5.0);
        double max2 = getMax(list2);
        System.out.println("第二种 max2: " + max2);
    }

    public static <T> T getMax(Collection<T> coll, Comparator<T> comp) {
        TreeSet<T> set = new TreeSet<>(comp);
        set.addAll(coll);
        T t = set.last();
        return t;
    }

    public static <T extends Comparable<T>> T getMax(Collection<T> coll) {
        T max = null;
        Iterator<T> it = coll.iterator();
        //获取第一个元素，赋值给max
        if(it.hasNext()) {
            max = it.next();
        }

        //遍历第2 - len个元素，逐个跟max比较
        while (it.hasNext()) {
            T t = it.next();
            if (t.compareTo(max) > 0) {
                max = t;
            }
        }

        return max;
    }
}
```





# 注解

## 12. 注解概念

简述以下四个元注解的作用？



答案：

- @Target，用于描述注解的使用范围，例如用在类上面还是方法上面
- @Retention，用于描述注解的保存策略，是保留到源代码中、Class文件中、还是加载到内存中
- @Documented，用于描述该注解将会被javadoc生产到API文档中
- @Inherited，用于表示某个被标注的类型是被继承的，如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。



