## 线程作业



### 1.什么是线程安全？

**答案：**

线程安全是指在多线程环境下，保证程序的正确性、稳定性和可靠性。具体来说，线程安全包含以下两个⽅⾯：

1. 原⼦性：对于多个线程共享的变量或对象，要求对它们的操作是原⼦性的，即对该变量或对象的读写操作是不可分割的。例如，对于⼀个整型变量的⾃增操作，要求该操作是原⼦性的，不能被其它线程的操作打断或⼲扰。
2. 互斥性：在多个线程同时访问共享资源时，要求对该资源的访问是互斥的，即任意时刻只能有⼀个线程访问该资源，其它线程需要等待。例如，在⼀个多线程程序中，如果多个线程同时访问同⼀个⽂件或数据库，就需要保证对该⽂件或数据库的访问是互斥的，否则可能会引发数据不⼀致或者数据损坏等问题。

总之，线程安全是⼀种程序设计的思想，它强调在多线程环境下保证程序的正确性和稳定性，避免多线程访问共享资源时的竞态条件、死锁等问题。



### 2.简述synchronized修饰静态方法和非静态方法的区别。

**答案：**

synchronized修饰静态⽅法时，该⽅法所在的类的所有实例对象共⽤同⼀把锁。也就是说，在静态⽅法中的代码块被⼀个线程执⾏时，其他所有线程都需要等待该线程释放锁后才能执⾏该代码块。这保证了同⼀时刻只有⼀个线程可以执⾏该代码块。

synchronized修饰⾮静态⽅法时，锁对象是该⽅法所属对象实例，不同实例之间的锁是独⽴的。换⾔之，如果⼀个线程获得了⼀个对象实例的锁，其他线程可以同时访问其他对象的同⼀个⽅法，因为它们的锁对象不同，不会相互影响。



### 3.描述wait()方法、sleep()方法和join()3个方法的异同点。

**答案：**

相同点：

- 它们都可以控制线程的执⾏状态。
- 它们都能使线程进⼊阻塞状态，等待⼀段时间后再继续执⾏
- 它们都可以⽤于解决线程之间的协作问题

不同点：

- wait()⽅法是Object类的⼀个⽅法，⽤于线程间通信；sleep()⽅法和join()⽅法是Thread类的⽅法，主要⽤于控制线程的执⾏状态。
- wait()⽅法会释放对象锁，sleep()⽅法和join()⽅法不会释放对象锁。
- wait()⽅法必须在同步代码块中调⽤，并且通常与synchronized关键字⼀起使⽤，⽽sleep()⽅法和
- join()⽅法可以在任何地⽅调⽤。
- wait()⽅法和notify()⽅法是配合使⽤的，notify()⽅法可以唤醒⼀个等待中的线程，⽽notifyAll()⽅法可以唤醒所有等待中的线程。sleep()⽅法和join()⽅法不需要唤醒其他线程。
- join()⽅法允许⼀个线程等待另⼀个线程执⾏完成后再继续执⾏，⽽wait()⽅法是等待其他线程唤醒该线程，sleep()⽅法是让线程休眠⼀段时间后再继续执⾏



### 4.编程题1

编写程序，实现以下要求：

1. 定义子线程1，线程处理函数中输出 1-50，每隔5ms输出一次
2. 定义子线程2，线程处理函数中输出 A-Z，每隔10ms输出一次
3. 要求，当线程1输出30之后，线程2插队进来优先输出，全部输出后，线程1再输出31-50。

```java
package com.briup.homework.day16;

public class Test04 {
    public static void main(String[] args) {
        //1.创建线程  注意：先创建th2
        Thread th2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for(char c = 'A'; c <= 'Z'; c++) {
                    System.out.println("in th2, c: " + c);

                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });

        Thread th1 = new Thread() {
            @Override
            public void run() {
                for(int i = 1; i <= 50; i++) {
                    System.out.println("in th1, i: " + i);

                    try {
                        Thread.sleep(5);

                        //th2插队进来优先执行
                        if(i == 30) {
                            th2.join();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };

        //2.启动线程
        th1.start();
        th2.start();
    }
}
```



### 5.编程题2

使用多线程编码实现：火车站卖票实例，四个卖票窗口随机卖出50张票(static成员tickers)

**注意:**

- 不能卖出重复的票，
- 不要卖出 编号为负值的票
- 每个窗口出票后 随机休眠时间范围在[100,200]ms

```java
package com.briup.homework.day16;

public class Test05 {
    public static void main(String[] args) {
        // 创建4个线程，模拟4个售票窗⼝
        Thread t1 = new Thread(new SaleTickets(), "窗⼝1");
        Thread t2 = new Thread(new SaleTickets(), "窗⼝2");
        Thread t3 = new Thread(new SaleTickets(), "窗⼝3");
        Thread t4 = new Thread(new SaleTickets(), "窗⼝4");

        //启动线程
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}

class SaleTickets implements Runnable {
    // 静态变量，表示剩余票数
    private static int tickers = 50;

    @Override
    public void run() {
        String name = Thread.currentThread().getName();
        while(tickers > 0) {
            synchronized (SaleTickets.class) {
                if(tickers > 0) {
                    System.out.println(name + " 卖出了第" + tickers + "张票");
                    tickers--;
                }

                //休眠一会  [100,200]
                try {
                    int n = (int)(Math.random() * (200-100+1)) + 100;
                    Thread.sleep(n);
                }catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



### 6.编程题3

创建两个线程，线程A从输出A-Z，线程B输出1-26，要求两个线程交替运行，最终输出的效果为：

A 1 B 2 C 3 ... Z 26

```java
package com.briup.homework.day16;

//1-26   A-Z  2个线程 交替运行
public class Test06 {
    //线程执行标记  0表示线程1执行    1表示线程2执行
    static int flag = 0;
	//使用 类普通成员flag 标志
    public static void main(String[] args) {
        //准备公共的锁对象
        final Object mutex = new Object();

        Thread th1 = new Thread() {
            @Override
            public void run() {
                for(int i = 1; i <= 26; i++) {
                    synchronized (mutex) {
                        if(flag == 1) {
                            try {
                                mutex.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        System.out.print(i + " ");

                        //修改标记
                        flag = 1;
                        //通知另一个线程执行
                        mutex.notify();
                    }
                }
            }
        };

        Thread th2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for(char c = 'A'; c <= 'Z'; c++) {
                    synchronized (mutex) {
                        if(flag == 0) {
                            try {
                                mutex.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }

                        System.out.print(c + " ");

                        //修改标记
                        flag = 0;
                        //通知另一个线程执行
                        mutex.notify();
                    }
                }
            }
        });

        //启动线程
        th1.start();
        th2.start();
    }
}
```



### 7.扩展题

**需求分析**：

假设现在有两个⽤户账户A和B，每个账户都有⼀定的余额，现在需要实现⼀个线程安全的转账功能：即⼀个⽤户可以将⼀定的⾦额转⼊到另⼀个⽤户账户中，具体要求如下：

1. ⽤户可以同时进⾏多次转账操作，每次转账的⾦额必须⼤于0，同时转出账户余额必须⼤于等于转账⾦额。
2. 转账过程中，需要对转出账户和转⼊账户加锁，保证同时只能有⼀个线程对某个账户进⾏转账操作。
3. 在进⾏转账操作时，需要按照账户名称的字典序进⾏排序，保证转账过程中的资源占⽤顺序⼀致，避免死锁的出现。
4. 转账操作完成后，需要释放相应的锁，并输出转账的⾦额和最新的账户余额。



提示1：银⾏账户类Account，包含以下属性：

​	String name ：账户名称

​	double balance ：账户余额

提示2：账户类Account，包含以下⽅法：

​	transfer(Account from, Account to, double amount) ；

​	从账户from中转出⼀定的⾦额，将其转⼊到账户to中。




编写测试程序，模拟多个⽤户同时进⾏转账操作，验证银⾏账户转账类的线程安全性。

```java
package com.briup.homework.day16;

import java.util.Random;

/*
假设现在有两个⽤户账户A和B，每个账户都有⼀定的余额，现在需要实现⼀个线程安全的转账功能：
即⼀个⽤户可以将⼀定的⾦额转⼊到另⼀个⽤户账户中，具体要求如下：
    1. ⽤户可以同时进⾏多次转账操作，每次转账的⾦额必须⼤于0，同时转出账户余额必须⼤于等于转账⾦额。
    2. 转账过程中，需要对转出账户和转⼊账户加锁，保证同时只能有⼀个线程对某个账户进⾏转账操作。
    3. 在进⾏转账操作时，需要按照账户名称的字典序进⾏排序，保证转账过程中的资源占⽤顺序⼀致，避免死锁的出现。
    4. 转账操作完成后，需要释放相应的锁，并输出转账的⾦额和最新的账户余额。
 */
public class Test07 {
    public static void main(String[] args) {
        // 创建两个账户
        Account a = new Account("A", 1000.0);
        Account b = new Account("B", 1000.0);

        Random random = new Random();

        for(int i = 0; i < 10; i++) {
            Thread th = new Thread() {
                @Override
                public void run() {
                    double amout = random.nextDouble() * 100;

                    //根据取值范围 进行 相互转账
                    //如果 随机数为 (30,80) 则A向B转账
                    if(amout > 30 && amout < 80) {
                        a.transfer(b,amout);
                    }else {//如果 随机数为 [0,30)或(80,100) 则A向B转账
                        b.transfer(a,amout);
                    }

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            };

            //启动线程
            th.start();
        }

    }
}

class Account {
    private String name; // 账户名称
    private double balance; // 账户余额

    public Account() {}

    public Account(String name, double balance) {
        this.name = name;
        this.balance = balance;
    }

    public String getName() {
        return name;
    }
    public double getBalance() {
        return balance;
    }

    // 存款
    public void deposit(double amount) {
        balance += amount;
    }
    // 取款
    public void withdraw(double amount) {
        balance -= amount;
    }

    // 转账
    public void transfer(Account to, double amount) {
        // 按照账户名称的字典序进⾏排序，保证转账过程中的资源占⽤顺序⼀致，避免死锁的出现
        Account mutex01 = (name.compareTo(to.getName()) < 0) ? this : to;
        Account mutex02 = (name.compareTo(to.getName()) < 0) ? to : this;

        //获取线程名
        String name = Thread.currentThread().getName();

        //为了避免死锁，两把锁的 上锁次序 要保持一致
        synchronized (mutex01) {
            synchronized (mutex02) {
                // 转出账户余额必须⼤于等于转账⾦额
                if (balance >= amount) {
                    //当前账户 取款
                    withdraw(amount);
                    //往另一账户 存款
                    to.deposit(amount);

                    System.out.println(name + "线程: from " + this.name + " to " + to.getName() + " 转账: " + amount);
                    System.out.println("转账成功后，"+ this.name + "余额: " + this.balance + " " +  to.name + "余额: " + to.balance);
                }else {
                    System.out.println(name + "线程: from " + this.name + " to " + to.getName() + " 转账失败：转账金额大于账户余额");
                    System.out.println("转账金额: " + amount + " 账户余额: " + balance);
                }
            }
        }
    }
}
```





